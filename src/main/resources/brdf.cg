#define NO_FLAGS (0)

// LBP2 compile flags
#define DECALS (1 << 0)
#define WATER_CAUSTICS (1 << 1)
#define SPRITELIGHT (1 << 2)
#define BAKED_AO (1 << 3)
#define DYNAMIC_AO (1 << 4)
#define AO_FLAGS (BAKED_AO | DYNAMIC_AO)
#define BAKED_SHADOWS (1 << 5)
#define DYNAMIC_SHADOWS (1 << 6)
#define SHADOW_FLAGS (BAKED_SHADOWS | DYNAMIC_SHADOWS)

// LBP1 compile flags
#define DEFERRED (1 << 7)
#define DEFERRED_NORMAL_PASS (1 << 8)

// Material properties
#define SPECULAR (1 << 9)
#define NORMAL (1 << 10)
#define ALPHA (1 << 11) // Not implemented for LBP2!
#define REFRACT (1 << 12)
#define GLOW (1 << 13)
#define GLASSY (1 << 14)

// Set this variable to define what maps this material uses.
#define PROPERTIES ENV.MATERIAL_PROPERTIES

// Set this variable to define how this shader is compiled.
// Refer to charts below for appropriate configurations.
#define FLAGS ENV.COMPILE_FLAGS

// LBP1 Shaders

// FLAGS[0] = DEFERRED_NORMAL_PASS
// FLAGS[1] = DEFERRED
// FLAGS[2] = DEFERRED | DECALS
// FLAGS[3] = DEFERRED | WATER_CAUSTICS

// LBP2 Shaders

// FLAGS[0] = BAKED_AO | BAKED_SHADOWS
// FLAGS[1] = SPRITELIGHT | DYNAMIC_SHADOWS | DYNAMIC_AO | DECALS
// FLAGS[2] = SPRITELIGHT | DYNAMIC_SHADOWS | DYNAMIC_AO
// FLAGS[3] = SPRITELIGHT | SHADOW_FLAGS | AO_FLAGS

// FLAGS[4] = WATER_CAUSTICS | BAKED_AO | BAKED_SHADOWS
// FLAGS[5] = WATER_CAUSTICS | SPRITELIGHT | DYNAMIC_SHADOWS | DYNAMIC_AO | DECALS
// FLAGS[6] = WATER_CAUSTICS | SPRITELIGHT | DYNAMIC_SHADOWS | DYNAMIC_AO
// FLAGS[7] = WATER_CAUSTICS | SPRITELIGHT | SHADOW_FLAGS | AO_FLAGS

// FLAGS[8] = NO_FLAGS
// FLAGS[9] = DECALS

float AlphaTestLevel = ENV.ALPHA_TEST_LEVEL;

float CosinePower = ENV.COSINE_POWER;

float BumpLevel = ENV.BUMP_LEVEL;

float ReflectionBlur = ENV.REFLECTION_BLUR;
float RefractiveIndex = ENV.REFRACTIVE_INDEX;

float normal_mul = 0.15;
float normal_add = 0.5;

float rim_round = 0.9;

#if ((FLAGS & DEFERRED) == 0)
    uniform float2 lightscaleadd;

    uniform float3 sunpos;
    uniform float3 rimcol2, ambcol, suncol;
    float3 rimcol = float3(0.5, 0.4, 0.3);

    #if (PROPERTIES & GLASSY)
        float2 oores = float2(0.00078125, 0.00138889);
    #endif

    #if (FLAGS & BAKED_AO)
        uniform float4 aotweak;
        sampler2D aomap: TEXUNIT8;
    #endif

    #if (FLAGS & BAKED_SHADOWS)
        sampler2D shadowmap: TEXUNIT14;
    #endif

    #if (FLAGS & DYNAMIC_SHADOWS)
        sampler2D shadowtex: TEXUNIT12;
        uniform float3 zmul;
    #endif

    #if (FLAGS & DYNAMIC_AO)
        sampler3D tex: TEXUNIT9;
        sampler3D tex_lo: TEXUNIT10;
    #endif

    #if ((FLAGS & SPRITELIGHT) || (FLAGS & DYNAMIC_AO))
        uniform float4 minaabb, maxaabb;
        uniform float4 maxaabb_add, maxaabb_normal;
    #endif

    #if (FLAGS & SPRITELIGHT)
        sampler3D sprlight_itex: TEXUNIT7;
        sampler3D sprlight_wstex: TEXUNIT11;
    #endif

    #if (FLAGS & WATER_CAUSTICS)
        uniform float4 watertweaks, causticuvscale;
        sampler2D caustic_tex: TEXUNIT6;
    #endif

    uniform float4 fogccparams;

#endif

uniform float4 fogcol;
uniform float4 tintcol;

// uniform float4 miscparams, dynamicWetnessParams, alphatestparams; 

sampler2D s0: TEXUNIT0;
sampler2D s1: TEXUNIT1;
sampler2D s2: TEXUNIT2;
sampler2D s3: TEXUNIT3;
sampler2D s4: TEXUNIT4;
sampler2D s5: TEXUNIT5;
sampler2D s6: TEXUNIT6;
sampler2D s7: TEXUNIT7;

#if (FLAGS & DECALS)
    #if ((FLAGS & DEFERRED) != 0)
        sampler2D itex: TEXUNIT10;
        sampler2D wstex: TEXUNIT11;
    #else
        sampler2D itex: TEXUNIT8;
        sampler2D wstex: TEXUNIT14;
    #endif
#endif

#if ((FLAGS & DEFERRED) && ((FLAGS & DEFERRED_NORMAL_PASS) == 0))
    sampler2D lbuf: TEXUNIT12;
    sampler2D zbuf: TEXUNIT13;
    sampler2D nbuf: TEXUNIT14;
#endif

sampler2D cbuf: TEXUNIT15;

// sampler3D bouncevolcol: TEXUNIT16;
// sampler3D bouncevoldir: TEXUNIT17;

#if (PROPERTIES & NORMAL)
half3 NormalMap(half4 iNormal, half4 iTangent, float4 sample) {
    half2 n = sample.yx;
    n.y = 1.0 - n.y;
    n -= 0.501953;

    half3 c = (n.y * iTangent.xyz) + (n.x * cross(iTangent.xyz, iNormal.xyz));
    float3 v = (-c * BumpLevel) + (iNormal.xyz / rsqrt(dot(n, n) - 0.25));
    return v / length(v);
}

half3 BumpMap(half4 iNormal, half4 iTangent, float4 sample) {
    half2 n = sample.yw - 0.501953;
    half3 c = (n.y * iTangent.xyz) + (n.x * cross(iTangent.xyz, iNormal.xyz));
    float3 v = (-c * BumpLevel) + (iNormal.xyz / rsqrt(dot(n, n) - 0.25));
    return normalize(v);
}

half3 GetNormalFromTexture(half4 iNormal, half4 iTangent, float4 iUV) {
ENV.AUTO_NORMAL_SETUP
}
#endif

#if (PROPERTIES & REFRACT)
float4 GetReflection(float2 iUV) {
ENV.AUTO_REFLECTION_SETUP
}
#endif

#if (PROPERTIES & SPECULAR)
float4 GetSpecularColor(float4 iUV, float4 iColor) {
ENV.AUTO_SPECULAR_SETUP
}
#endif

float4 GetDiffuseColor(float4 iUV, float4 iColor) {
ENV.AUTO_DIFFUSE_SETUP
}

#if (PROPERTIES & GLOW)
float4 GetGlowColor(float4 iUV, float4 iColor) {
ENV.AUTO_GLOW_SETUP
}
#endif

#if (PROPERTIES & ALPHA)
bool DoAlphaTest(float4 iUV, float4 iColor) {
ENV.AUTO_ALPHA_SETUP
}
#endif

#if (FLAGS & DECALS)
float4 GetDecals(float3 iDecalUV) {
    float2 dcoord = (frac(iDecalUV.xy * 256.0) * 127.0 + floor(tex2D(itex, iDecalUV.xy).xy * 32640.0 + 0.5) + 0.5) * 0.000488281;
    return tex2D(wstex, dcoord);
}
#endif

#if ((FLAGS & DEFERRED) == 0)
    float3 GetWorldPos(float4 iVec2Eye) {
        return (((iVec2Eye - minaabb) * maxaabb) + maxaabb_add).xyz;
    }

    #if (FLAGS & DYNAMIC_AO)
    float DynamicAO(float4 iVec2Eye, half3 iNormal) {
        half4 aoNormal = half4(iNormal, 1.0);
        float4 worldPos = float4(GetWorldPos(iVec2Eye), 0.0);
        aoNormal.y += 0.75; // push towards the sky
        aoNormal.xyz *= maxaabb_normal.xyz;

        worldPos.xyz += aoNormal.xyz;

        float ao = tex3Dlod(tex, worldPos).z;
        worldPos.xyz += aoNormal.xyz;
        ao += tex3Dlod(tex_lo, worldPos).z;
        worldPos.xyzw += aoNormal.xyzw;
        ao += tex3Dlod(tex_lo, worldPos).z;
        worldPos.xyzw += aoNormal.xyzw;
        ao += tex3Dlod(tex_lo, worldPos).z;
        
        return 1 - ao * minaabb.w;
    }
    #endif

    #if (FLAGS & AO_FLAGS)
    float GetAO(half3 iNormal, float4 iVec2Eye, float2 iLightmapUV) {
        #if ((FLAGS & AO_FLAGS) == AO_FLAGS)
            float ao = DynamicAO(iVec2Eye, iNormal);
            return min(ao, (tex2D(aomap, iLightmapUV).w * aotweak.x) + aotweak.y);
        #elif (FLAGS & DYNAMIC_AO)
            return DynamicAO(iVec2Eye, iNormal);
        #elif (FLAGS & BAKED_AO)
            return (tex2D(aomap, iLightmapUV).w * aotweak.x) + aotweak.y;
        #endif
    }
    #endif


    #if (FLAGS & DYNAMIC_SHADOWS)
    half GetDynamicShadow(float4 iShadowMapPosition, float4 iVec2Eye) {
        float3 lightVec = (iVec2Eye.xyz - sunpos) * lightscaleadd.x;
        float shadowPos = (abs(dot(lightVec, lightVec)) / length(lightVec)) - lightscaleadd.y;
        half shadow = 1.0;
        if (shadowPos < 1.0) {
            half4 shadowProj = tex2Dproj(shadowtex, iShadowMapPosition);
            float2 s = (shadowProj.zw * 0.03125) + shadowProj.xy;

            half h4x = s.x - shadowPos; 
            s.y = saturate((-s.x * s.x) + s.y) + 0.00005;
            float r3w = s.y / (pow(h4x, 2) + s.y);
            r3w += saturate((iVec2Eye.z * zmul.x) + zmul.y);

            shadow = saturate(max(0.0 <= h4x, r3w));
        }
        return shadow;
    }
    #endif

    #if (FLAGS & SHADOW_FLAGS)
    half GetShadow(float4 iShadowMapPosition, float2 iLightmapUV, float4 iVec2Eye) {
        #if ((FLAGS & SHADOW_FLAGS) == SHADOW_FLAGS)
            half shadow = GetDynamicShadow(iShadowMapPosition, iVec2Eye);
            return min(shadow, tex2D(shadowmap, iLightmapUV).x);
        #elif (FLAGS & BAKED_SHADOWS)
            return tex2D(shadowmap, iLightmapUV).x; // baked shadow, is this used for static meshes?
        #elif (FLAGS & DYNAMIC_SHADOWS)
            return GetDynamicShadow(iShadowMapPosition, iVec2Eye);
        #endif
    }
    #endif

    #if (FLAGS & WATER_CAUSTICS)
    float2 GetCaustic(float4 iVec2Eye, float3 iLightVec, float iNdotL, float iShadow) {
        float waterDirection = max(watertweaks.y - iVec2Eye.y, 0.0);
        float causticScale = 1.0, causticOverlay = 0.0;
        if (waterDirection > 0.0) {
            float2 causticuv = (iVec2Eye.xz * causticuvscale.xy) + causticuvscale.zw;
            causticuv += ((iLightVec.xz * waterDirection) * 0.00005);
            
            float caustic = tex2D(caustic_tex, causticuv).x - 0.5;
            caustic *= (saturate((iShadow * saturate(-iNdotL)) + 0.125) * max((-waterDirection * 0.000025) + 1.0, 0.0));

            float direction = min(waterDirection * 0.0125, 1.0);

            caustic *= (3.0 * direction);

            causticOverlay = max(min(caustic, 0.25), -0.25);
            causticScale = ((causticOverlay * direction) - direction) + 1.0;
        }

        return float2(causticScale, causticOverlay);
    }
    #endif
#endif

#if (FLAGS & DEFERRED)

#if (FLAGS & WATER_CAUSTICS)
    #define DEFERRED_POS_OFFSET float2(0.003125, 0.00555556)
    #define DEFERRED_ZBUF_OFFSET float2(0.00078125, 0.0)
    #define DEFERRED_LNBUF_OFFSET (zbfs * 0.199219)
#else
    #define DEFERRED_POS_OFFSET float2(0.00078125, 0.00138889)
    #define DEFERRED_ZBUF_OFFSET float2(0.000195313, 0.0)
    #define DEFERRED_LNBUF_OFFSET (zbfs * 0.0498047)
#endif

half2 encode(half3 normal) {
    half2 encoded = normal.xy;
    half z = length(normal + half3(0.0, 0.0, 1.0));
    return (encoded / z / 2.0) + 0.5;
}

half3 decode(half2 encoded_normal) {
    half2 n = (encoded_normal * 2.0) - 1.0;
    half z = 1.0 - dot(n, n);
    half3 normal = half3(n, abs(z) / sqrt(z)) / rsqrt(z) * 2.0;
    normal.z -= 1.0;
    return normal;
}

// LBP1 main
void main(
    float4 iUV: TEXCOORD0,
    float4 iTangent: TEXCOORD1,
    half4 iNormal: TEXCOORD2,
    float3 iDecalUV: TEXCOORD3,
    float3 iVec2Eye: TEXCOORD4,
    float4 iPositionNew: TEXCOORD5,
    float4 iPositionOld: TEXCOORD6,

    float4 iWorldPos: WPOS,
    float4 iColor: COLOR0,

    out half4 color_out: COLOR0
) {
    #if (PROPERTIES & ALPHA)
        if (DoAlphaTest(iUV, iColor)) discard;
    #endif

    // First normal pass shader
    #if ((FLAGS & DEFERRED_NORMAL_PASS) == (DEFERRED_NORMAL_PASS))
        #if (PROPERTIES & NORMAL)
            half3 normal = GetNormalFromTexture(iNormal, iTangent, iUV);
        #else
            half3 normal = normalize(iNormal.xyz);
        #endif

        float2 delta = ((iPositionNew.xy / iPositionNew.w) - (iPositionOld.xy / iPositionOld.w)) * 4.0;
        color_out = half4(
            encode(normal),
            float2(delta.x, -delta.y) + 0.503922
        );
    // The actual color shaders
    #else
        float2 pos = iWorldPos.xy * DEFERRED_POS_OFFSET;
        pos.y = 1.0 - pos.y;

        float zbfs = tex2D(zbuf, pos - DEFERRED_ZBUF_OFFSET).w;

        // In LBP1, the left side of the normal buffer has transparency.
        #if (PROPERTIES & GLASSY)
            float2 pixelPos = float2(-DEFERRED_LNBUF_OFFSET + pos.x, pos.y);
        #else
            float2 pixelPos = float2(DEFERRED_LNBUF_OFFSET + pos.x, pos.y);
        #endif

        #if ((PROPERTIES & GLASSY) || (PROPERTIES & REFRACT))
            float2 nbfs = tex2D(nbuf, pixelPos).xy;
            half3 normal = decode(nbfs);
        #endif

        float4 lbfs = tex2D(lbuf, pixelPos);

        half3 diffuse = GetDiffuseColor(iUV, iColor).xyz;
        #if (FLAGS & DECALS)
            float4 decals = GetDecals(iDecalUV);
            diffuse = (diffuse * decals.w) + decals.xyz;
        #endif

        half3 prod = pow(lbfs.xyz, 2);

        #if (PROPERTIES & REFRACT)
            float3 viewDir = iVec2Eye / length(iVec2Eye);
            half3 reflection = GetReflection(reflect(viewDir, normal).xy).xyz;
            reflection *= dot(prod, float3(0.299072, 0.586914, 0.114014));
        #else
            half3 reflection = half3(0.0, 0.0, 0.0); // Dummy addition variable.
        #endif

        #if (PROPERTIES & SPECULAR)
            float3 specular = GetSpecularColor(iUV, iColor).xyz;
            half3 lobe = (((lbfs.w * prod) * specular) + (specular * reflection)) * 2;
        #else
            half3 lobe = reflection;
        #endif

        #if (PROPERTIES & GLASSY)
            half2 n = nbfs - 0.501961;

            float2 cuv = (n * (RefractiveIndex * float2(9.0, -16.0))) + (pos + float2(0.000195313, 0.0));
            cuv.x = (round(cuv.x * 1280.0) * 0.00078125) - 0.000195313;
            float3 cbfs = tex2D(cbuf, cuv).xyz;

            half3 color = ((diffuse * tintcol.xyz) * cbfs) + (lobe * 2) + (prod * pow(saturate(dot(n, n) * 10.0 - 0.5), 2));
        #else
            half3 color = (diffuse * prod) + lobe;
        #endif

        #if (PROPERTIES & GLOW)
            color += GetGlowColor(iUV, iColor).xyz;
        #endif

        #if (PROPERTIES & GLASSY)
            color_out = half4(color, 1.0);
        #else
            color.x = abs(color.x * tintcol.x) / sqrt(color.x * tintcol.x);
            color.y = abs(color.y * tintcol.y) / sqrt(color.y * tintcol.y);
            color.z = abs(color.z * tintcol.z) / sqrt(color.z * tintcol.z);

            color = clamp(iDecalUV.z, 0.0f, 1.0) * (-color + fogcol.xyz) + color;

            half factor = max(max(color.x, max(color.y, color.z)), 1.0);
            color_out = half4(
                color / factor,
                (1.0 / factor) / 2
            );
        #endif
    #endif
}
#else


// XYZ = Diffuse Light Color, W = Specular Lobe
float4 GetLight(half3 iNormal, float4 iVec2Eye, float4 iShadowMapPosition, float2 iLightmapUV) {
    float3 viewVec = iVec2Eye.xyz / length(iVec2Eye.xyz);
    float3 reflectVec = reflect(viewVec, iNormal);
    float3 lightVec = normalize((iVec2Eye.xyz - sunpos) * lightscaleadd.x);

    float NdotV = dot(iNormal, viewVec);
    float RdotL = dot(reflectVec, lightVec);
    float NdotL = dot(iNormal, lightVec); 

    #if (FLAGS & AO_FLAGS)
        float ao = GetAO(iNormal, iVec2Eye, iLightmapUV);
    #else
        float ao = 1.0; // Dummy multiplication variable, will be optimized out.
    #endif

    #if (FLAGS & SHADOW_FLAGS)
        half shadow = GetShadow(iShadowMapPosition, iLightmapUV, iVec2Eye);
    #else
        half shadow = 1.0; // Dummy multiplication variable, will be optimized out.
    #endif

    #if (FLAGS & WATER_CAUSTICS)
        float2 caustic = GetCaustic(iVec2Eye, lightVec, NdotL, shadow);
    #endif

    // ...ambient a simple 2 color hemisphere
    float3 color = ((iNormal.y * normal_mul) + normal_add) * ambcol;

    #if (FLAGS & AO_FLAGS)
        color *= ao;
    #endif

    #if (FLAGS & WATER_CAUSTICS)
        color += (color * caustic.y);
        color += ((((shadow * saturate(-NdotL)) * ao) * caustic.x) * suncol);
    #else
        color += ((ao * (shadow * saturate(-NdotL))) * suncol);
    #endif

    // ... the 2 rim lights are lerp'ed between based on sunlight shadow
    color += (shadow * saturate(
        // based on (V.N)^2 w/ bias & scale
        pow(saturate(NdotV + rim_round), 2) * 
        lerp(rimcol, rimcol2, (iNormal.y + 1.0) / 2.0)
    ));

    float specular = pow(saturate(-RdotL), CosinePower);
    #if (FLAGS & SPRITELIGHT)
        float3 worldPos = GetWorldPos(iVec2Eye);

        float3 ws = (tex3D(sprlight_wstex, worldPos).xyz - 0.5) * 2.0;
        ws /= sqrt(dot(ws, ws) + 0.0010004);
        float RdotS = saturate(dot(reflectVec, ws));
        float NdotS = dot(iNormal, ws);

        float3 spritelight = tex3D(sprlight_itex, worldPos).xyz * ao;

        color += (max((NdotS + 0.199951), 0.0) * spritelight);

        // It's probably problematic to do this here, but whatever, I'll fix it later.
        specular += (spritelight * (pow(RdotS, 22.0) * (NdotS > 0.0))).x;
    #endif

    return float4(color, specular);
}

// LBP2 Main
void main(
    float4 iUV: TEXCOORD0,
    float4 iTangent: TEXCOORD1,
    half4 iNormal: TEXCOORD2,
    float3 iDecalUV: TEXCOORD3,
    float4 iVec2Eye: TEXCOORD4,
    float4 iShadowMapPosition: TEXCOORD6,
    float2 iLightmapUV: TEXCOORD7,

    float4 iWorldPos: WPOS,

    float4 iColor: COLOR0,

    out half4 color_out: COLOR0
) {
    #if (PROPERTIES & NORMAL)
        half3 normal = GetNormalFromTexture(iNormal, iTangent, iUV);
    #else
        half3 normal = normalize(iNormal.xyz);
    #endif

    half3 diffuse = GetDiffuseColor(iUV, iColor).xyz;
    #if (FLAGS & DECALS)
        float4 decals = GetDecals(iDecalUV);
        diffuse = (diffuse * decals.w) + decals.xyz;
    #endif

    float4 light = GetLight(normal, iVec2Eye, iShadowMapPosition, iLightmapUV);
    float3 prod = light.xyz * light.xyz;

    #if (PROPERTIES & REFRACT)
        float3 viewVec = iVec2Eye.xyz / length(iVec2Eye.xyz); 
        float3 reflection = GetReflection(reflect(viewVec, normal).xy).xyz;
        reflection *= dot(prod, float3(0.299072, 0.586914, 0.114014));
    #else
        float3 reflection = float3(0.0, 0.0, 0.0); // Dummy addition variable.
    #endif

    #if (PROPERTIES & SPECULAR)
        float3 specular = GetSpecularColor(iUV, iColor).xyz;
        half3 lighting = (((light.w * prod) * specular) + (specular * reflection)) * 2.0;
    #else
        half3 lighting = reflection;
    #endif 
    
    #if (PROPERTIES & GLASSY)
        float2 wpos = iWorldPos.xy * oores;
        float2 cuv = (normal.xy * (RefractiveIndex * float2(9.0, -16.0))) + float2(wpos.x, 1.0 - wpos.y);
        half n = saturate((dot(normal.xy, normal.xy) * 10.0) - 0.5);
        half3 color = (prod * pow(n, 2)) + ((diffuse * tintcol.xyz) * tex2D(cbuf, cuv).xyz) + (lighting * 2.0);
    #else
        half3 color = (diffuse * prod) + lighting;
    #endif

    half illumination = tintcol.w;
    half factor = saturate(iDecalUV.z);

    #if (PROPERTIES & GLOW)
        half3 glow = GetGlowColor(iUV, iColor).xyz;
        color += glow;
        float r = 1.0 / ((dot(glow, glow) * 4.0) + 1.0);
        illumination *= (r + ((-r * factor) + factor));
    #endif

    #if ((PROPERTIES & GLASSY) == 0)
        color.x = sqrt(color.x * tintcol.x);
        color.y = sqrt(color.y * tintcol.y);
        color.z = sqrt(color.z * tintcol.z);
    #endif
    
    float fogcc = ((dot(color, float3(0.3, 0.6, 0.1)) + fogccparams.y) * fogccparams.x) + 1.0;
    float3 fog = (fogcc * fogcol.xyz) - color;
    
    #if (PROPERTIES & ALPHA)
        if (DoAlphaTest(iUV, iColor)) illumination = 0.0;
    #endif

    color_out = half4(
        color + (factor * fog),
        illumination
    );
} 
#endif